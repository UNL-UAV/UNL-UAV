{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"UNL Aerospace UAV IARC Team Who We Are UNL Aerospace UAV IARC Team, known as UNL UAV, is a student-led design team operating under the UNL Aerospace Student Organization . We are focused on designing and building an autonomous drone and mechanical robotic manipulation payload systems capable of accomplishing the AUVSI IARC Mission 9 directives. Getting Involved UAV Team General meetings are held over Zoom on Wednesday's at 8:00PM CST and in Nebraska Hall W347 . The UNL Aerospace Club Lab is located at Nebraska Hall W127 . Join Zoom Meeting https://unl.zoom.us/j/98614962923 Meeting ID: 986 1496 2923 If you would like to join the team, please reach out to one of our members ont the Contact Us page. Mission 9 Objective Fly fully autonomous Use ONBOARD computing (no data links except for kill switch and safety pilot override) Avoid obstacles including: Other aerial robots Physical obstacles Conduct the mission successfully (replace the module and return home) under 9 minutes A detailed arena layout of the course can be seen in the image below. A link to the AUVSI IARC Mission 9 rules can be found under the resources page. What is AUVSI IARC The Association for Unmanned Vehicle Systems International (AUVSI), the world's largest nonprofit organization dedicated to the advancement of unmanned systems and robotics, represents corporations and professionals from more than 60 countries involved in industry, government and academia. AUVSI members work in the defense, civil and commercial markets. Visit AUVSI at www.auvsi.org . The IARC is the longest running collegiate aerial robotics competition in the world, challenging competing teams to develop robotic aerial systems considered impossible for any robots currently owned by government or industry. The IARC proceeds in a series of 'missions', with teams continuing to attempt a particular mission for multiple years until one team succeeds and a new mission is started. Visit the IARC challenge at www.aerialroboticscompetition.org . Contact Us If you are interested in collaborating, or have questions, feel free to reach out to one of us. Contact information for members can be found on the Contact Page or People Page . License This website is released using Creative Commons Attribution license.","title":"Home"},{"location":"#who-we-are","text":"UNL Aerospace UAV IARC Team, known as UNL UAV, is a student-led design team operating under the UNL Aerospace Student Organization . We are focused on designing and building an autonomous drone and mechanical robotic manipulation payload systems capable of accomplishing the AUVSI IARC Mission 9 directives.","title":"Who We Are"},{"location":"#getting-involved","text":"UAV Team General meetings are held over Zoom on Wednesday's at 8:00PM CST and in Nebraska Hall W347 . The UNL Aerospace Club Lab is located at Nebraska Hall W127 . Join Zoom Meeting https://unl.zoom.us/j/98614962923 Meeting ID: 986 1496 2923 If you would like to join the team, please reach out to one of our members ont the Contact Us page.","title":"Getting Involved"},{"location":"#mission-9-objective","text":"Fly fully autonomous Use ONBOARD computing (no data links except for kill switch and safety pilot override) Avoid obstacles including: Other aerial robots Physical obstacles Conduct the mission successfully (replace the module and return home) under 9 minutes A detailed arena layout of the course can be seen in the image below. A link to the AUVSI IARC Mission 9 rules can be found under the resources page.","title":"Mission 9 Objective"},{"location":"#what-is-auvsi-iarc","text":"The Association for Unmanned Vehicle Systems International (AUVSI), the world's largest nonprofit organization dedicated to the advancement of unmanned systems and robotics, represents corporations and professionals from more than 60 countries involved in industry, government and academia. AUVSI members work in the defense, civil and commercial markets. Visit AUVSI at www.auvsi.org . The IARC is the longest running collegiate aerial robotics competition in the world, challenging competing teams to develop robotic aerial systems considered impossible for any robots currently owned by government or industry. The IARC proceeds in a series of 'missions', with teams continuing to attempt a particular mission for multiple years until one team succeeds and a new mission is started. Visit the IARC challenge at www.aerialroboticscompetition.org .","title":"What is AUVSI IARC"},{"location":"#contact-us","text":"If you are interested in collaborating, or have questions, feel free to reach out to one of us. Contact information for members can be found on the Contact Page or People Page .","title":"Contact Us"},{"location":"#license","text":"This website is released using Creative Commons Attribution license.","title":"License"},{"location":"contact/","text":"Contact Us General Questions For all general questions, please contact Andrew Hossack or Khawm Mung Questions can also be sent through the Google Feedback form Here (slower response time) Subteam Group Contact Software Gerson Uriarte Hardware Zury Vasquez Electrical Ryan Karl at ryan.c.karl@gmail.com Systems Engineering Grace Becker at grace.becker@huskers.unl.edu","title":"Contact Us"},{"location":"contact/#contact-us","text":"","title":"Contact Us"},{"location":"contact/#general-questions","text":"For all general questions, please contact Andrew Hossack or Khawm Mung Questions can also be sent through the Google Feedback form Here (slower response time)","title":"General Questions"},{"location":"contact/#subteam-group-contact","text":"","title":"Subteam Group Contact"},{"location":"contact/#software","text":"Gerson Uriarte","title":"Software"},{"location":"contact/#hardware","text":"Zury Vasquez","title":"Hardware"},{"location":"contact/#electrical","text":"Ryan Karl at ryan.c.karl@gmail.com","title":"Electrical"},{"location":"contact/#systems-engineering","text":"Grace Becker at grace.becker@huskers.unl.edu","title":"Systems Engineering"},{"location":"credits/","text":"Credits Thanks to @Root3287 for setting up the original page on 8/5/2020. For site maintance, create an issue on our github page","title":"Credits"},{"location":"credits/#credits","text":"Thanks to @Root3287 for setting up the original page on 8/5/2020. For site maintance, create an issue on our github page","title":"Credits"},{"location":"people/","text":"People Admins Andrew Hossack - President UNL Aerospace UAV IARC Team President. I am currently a Junior studying Computer Engineering. Contact by email at Ahossack2@unl.edu . Khawm Mung - Director of Development Works with the administrative side and team development. Responsible for maintaining budget, membership requirements, and technical details for sponsorship such as NASA NE Space Grant. Contact by email at khawm.mung@huskers.unl.edu . Team Leads Grace Becker - Systems Engineering Grace is a senior getting her bachelor\u2019s in civil engineering. As the Systems Engineer, she bridges the gap between software and hardware; making sure both teams are adhering to criteria and constraints and creating designs and architecture that are realistic to integrate and execute. She also pushes the schedule to make sure design milestones are met at a pace that shows progress. Contact by email at grace.becker@huskers.unl.edu . Gerson Uriarte - Software Team Lead Pursuing a Bachelor of Science in Computer Engineering and pre-med status. Work with the software team to develop software that will be on the companion computer, controlling the UAS. Currently doing research at Nimbus Labs on campus. I want to go to med school but am passionate about technology and computers. I enjoy working on software and doing research. Contact by email at gersongru@huskers.unl.edu . Zury Vasquez - Hardware Team Lead My name is Zury and in a senior electrical engineering student. I work as a hardware lead on the Aerospace UAV team. I love learning about technology and enjoy exploring. Contact by email at 25zvasquez@gmail.com . Members Timothy Gibbons - Software Developer Website System Adminitration Wizard and Website Maintainer Systems administrator and command-line guru. Tim is responsible for maintenance and upkeep of the Ubuntu Server, as well as managing most things internet-connected. Pradhyun Kashyap - Remote Pilot and Support Unmanned aircraft systems, or drones are no longer toys or hobby, these are now a tool for entry into dozens of lucrative careers. As a Certified Remote Pilot, my job is to manage unmanned aerial vehicle flight operations and make sure to practice all the procedures and policies from Federal Aviation Administration (FAA) to include standard flight and ground operations. Also, my primary tasks include building flight vehicle structure and related components as a support assistance to the hardware team. Akshay Bhandari - Hardware Engineer I am a senior, majoring in Mechanical Engineering at the University of Nebraska-Lincoln. I am an engineer for the hardware team. My job is to design and manufacture the manipulator system, especially the Gripper. I make 3D models of the system using AutoCAD, Solidworks and Autodesk Inventor. I have great passion for Manufacturing. I have had three technical internships, related to manufacturing, over my undergraduate course. I plan to graduate in Fall 2020, and work with my family thereafter.","title":"People"},{"location":"people/#people","text":"","title":"People"},{"location":"people/#admins","text":"","title":"Admins"},{"location":"people/#andrew-hossack-president","text":"UNL Aerospace UAV IARC Team President. I am currently a Junior studying Computer Engineering. Contact by email at Ahossack2@unl.edu .","title":"Andrew Hossack - President"},{"location":"people/#khawm-mung-director-of-development","text":"Works with the administrative side and team development. Responsible for maintaining budget, membership requirements, and technical details for sponsorship such as NASA NE Space Grant. Contact by email at khawm.mung@huskers.unl.edu .","title":"Khawm Mung - Director of Development"},{"location":"people/#team-leads","text":"","title":"Team Leads"},{"location":"people/#grace-becker-systems-engineering","text":"Grace is a senior getting her bachelor\u2019s in civil engineering. As the Systems Engineer, she bridges the gap between software and hardware; making sure both teams are adhering to criteria and constraints and creating designs and architecture that are realistic to integrate and execute. She also pushes the schedule to make sure design milestones are met at a pace that shows progress. Contact by email at grace.becker@huskers.unl.edu .","title":"Grace Becker - Systems Engineering"},{"location":"people/#gerson-uriarte-software-team-lead","text":"Pursuing a Bachelor of Science in Computer Engineering and pre-med status. Work with the software team to develop software that will be on the companion computer, controlling the UAS. Currently doing research at Nimbus Labs on campus. I want to go to med school but am passionate about technology and computers. I enjoy working on software and doing research. Contact by email at gersongru@huskers.unl.edu .","title":"Gerson Uriarte - Software Team Lead"},{"location":"people/#zury-vasquez-hardware-team-lead","text":"My name is Zury and in a senior electrical engineering student. I work as a hardware lead on the Aerospace UAV team. I love learning about technology and enjoy exploring. Contact by email at 25zvasquez@gmail.com .","title":"Zury Vasquez - Hardware Team Lead"},{"location":"people/#members","text":"","title":"Members"},{"location":"people/#timothy-gibbons-software-developer","text":"Website System Adminitration Wizard and Website Maintainer Systems administrator and command-line guru. Tim is responsible for maintenance and upkeep of the Ubuntu Server, as well as managing most things internet-connected.","title":"Timothy Gibbons - Software Developer"},{"location":"people/#pradhyun-kashyap-remote-pilot-and-support","text":"Unmanned aircraft systems, or drones are no longer toys or hobby, these are now a tool for entry into dozens of lucrative careers. As a Certified Remote Pilot, my job is to manage unmanned aerial vehicle flight operations and make sure to practice all the procedures and policies from Federal Aviation Administration (FAA) to include standard flight and ground operations. Also, my primary tasks include building flight vehicle structure and related components as a support assistance to the hardware team.","title":"Pradhyun Kashyap - Remote Pilot and Support"},{"location":"people/#akshay-bhandari-hardware-engineer","text":"I am a senior, majoring in Mechanical Engineering at the University of Nebraska-Lincoln. I am an engineer for the hardware team. My job is to design and manufacture the manipulator system, especially the Gripper. I make 3D models of the system using AutoCAD, Solidworks and Autodesk Inventor. I have great passion for Manufacturing. I have had three technical internships, related to manufacturing, over my undergraduate course. I plan to graduate in Fall 2020, and work with my family thereafter.","title":"Akshay Bhandari - Hardware Engineer"},{"location":"resources/","text":"Resources Useful Links UNL Aerospace Website IARC Mission 9 Rules UNL Aerospace GitHub UAV Quire AUVSI IARC Foundation Website Creating Documention This is a useful guide on how to start writing documentation. We will be using git to control what information get in and what information doesn't get in. Novice This is indended for people who is less technical about git and github. Just want to publish an documentation. Here is how to do it. Go to GitHub Create an account Go to our Documentation Repo Click Issues Create new Issue If applicable select add documentation template. Fill out the form. Attach your information that you want to publish. Submit Wait for it to publish Advanced This is for the people who want to get done now and knows git/github. Login to Github Fork the Repository. Use the clone command for your forked repository. (Check how below) Add, Modify, Remove your forked repository with the necessary documents. Create Pull Request on UNL-UAV Repo. Resources/FAQ Git Resources Give a man a fish and you feed him for a day; Teach a man to fish and you feed him for a lifetime. Try Git Markdown Resources Learn Markdown Cheat Sheet Live Editor Cloning the Repository git clone https://github.com/UNL-UAV/unl-uav.github.io --branch docs . Make sure you have --branch docs otherwise you will enter in the wrong branch. Adding Documents Add all new documents in the /docs/ directory. With the extension of .md . Commit and push. Deploying Deploying to the website is as simple as pushing to the docs repository. It will take up to a minute for the website to load and refreash the cache. To bypass the cache you can press either key combination: CTRL+R Command+R Shift+F5 Shift+Reload Button CTRL+F5 Additional resources can be found on the club's Google Drive and Box accounts.","title":"Resources"},{"location":"resources/#resources","text":"","title":"Resources"},{"location":"resources/#useful-links","text":"UNL Aerospace Website IARC Mission 9 Rules UNL Aerospace GitHub UAV Quire AUVSI IARC Foundation Website","title":"Useful Links"},{"location":"resources/#creating-documention","text":"This is a useful guide on how to start writing documentation. We will be using git to control what information get in and what information doesn't get in.","title":"Creating Documention"},{"location":"resources/#novice","text":"This is indended for people who is less technical about git and github. Just want to publish an documentation. Here is how to do it. Go to GitHub Create an account Go to our Documentation Repo Click Issues Create new Issue If applicable select add documentation template. Fill out the form. Attach your information that you want to publish. Submit Wait for it to publish","title":"Novice"},{"location":"resources/#advanced","text":"This is for the people who want to get done now and knows git/github. Login to Github Fork the Repository. Use the clone command for your forked repository. (Check how below) Add, Modify, Remove your forked repository with the necessary documents. Create Pull Request on UNL-UAV Repo.","title":"Advanced"},{"location":"resources/#resourcesfaq","text":"","title":"Resources/FAQ"},{"location":"resources/#git-resources","text":"Give a man a fish and you feed him for a day; Teach a man to fish and you feed him for a lifetime. Try Git","title":"Git Resources"},{"location":"resources/#markdown-resources","text":"Learn Markdown Cheat Sheet Live Editor","title":"Markdown Resources"},{"location":"resources/#cloning-the-repository","text":"git clone https://github.com/UNL-UAV/unl-uav.github.io --branch docs . Make sure you have --branch docs otherwise you will enter in the wrong branch.","title":"Cloning the Repository"},{"location":"resources/#adding-documents","text":"Add all new documents in the /docs/ directory. With the extension of .md . Commit and push.","title":"Adding Documents"},{"location":"resources/#deploying","text":"Deploying to the website is as simple as pushing to the docs repository. It will take up to a minute for the website to load and refreash the cache. To bypass the cache you can press either key combination: CTRL+R Command+R Shift+F5 Shift+Reload Button CTRL+F5 Additional resources can be found on the club's Google Drive and Box accounts.","title":"Deploying"},{"location":"teams/","text":"Teams Software The software subteam is tasked with developing and integrating systems and technologies to keep the drone in the sky. The team uses technologies including C++, Linux, git, and the Robot Operating System, as well as the MAVLink protocol and Open Computer Vision. The software subteam is comprised of two project teams that work in an agile software development environment. The two project teams, led by experienced project managers, focus on two separate areas: navigation and vision/intelligence. The navigation project team deals with processing the geographical position of the drone, plotting best possible courses, and optimizing drone flight patterns. The vision/intelligence team deals with machine perception and processing video data. The data is compiled and interpreted to present the drone with a best course of action in any scenario. If you are interested in software engineering, machine perception, computer vision, artificial intelligence, or automata, this is the team for you! Hardware For all the software work that goes into a UAV, it can't get off the ground without the necessary mechanical structures and systems for the software to interact with. To this end, our Hardware Group is tasked with designing, producing, and assembling all structural and mechanical components of the aerial system. These components have included everything from custom landing legs and specialty components for completing the competition, to a solution for battery attachment and testing and maintenance on the frame. This requires familiarity with the tools and equipment necessary for effective component production, including power tools, machine tools, and even a 3D printer, as well as computing tools. The computing tools used by the Hardware Group mostly consist of the program SolidWorks, to include its 3D CAD design suite, as well as structural and fluid simulation. When simulations require a second opinion, ANSYS is utilized.","title":"Teams"},{"location":"teams/#teams","text":"","title":"Teams"},{"location":"teams/#software","text":"The software subteam is tasked with developing and integrating systems and technologies to keep the drone in the sky. The team uses technologies including C++, Linux, git, and the Robot Operating System, as well as the MAVLink protocol and Open Computer Vision. The software subteam is comprised of two project teams that work in an agile software development environment. The two project teams, led by experienced project managers, focus on two separate areas: navigation and vision/intelligence. The navigation project team deals with processing the geographical position of the drone, plotting best possible courses, and optimizing drone flight patterns. The vision/intelligence team deals with machine perception and processing video data. The data is compiled and interpreted to present the drone with a best course of action in any scenario. If you are interested in software engineering, machine perception, computer vision, artificial intelligence, or automata, this is the team for you!","title":"Software"},{"location":"teams/#hardware","text":"For all the software work that goes into a UAV, it can't get off the ground without the necessary mechanical structures and systems for the software to interact with. To this end, our Hardware Group is tasked with designing, producing, and assembling all structural and mechanical components of the aerial system. These components have included everything from custom landing legs and specialty components for completing the competition, to a solution for battery attachment and testing and maintenance on the frame. This requires familiarity with the tools and equipment necessary for effective component production, including power tools, machine tools, and even a 3D printer, as well as computing tools. The computing tools used by the Hardware Group mostly consist of the program SolidWorks, to include its 3D CAD design suite, as well as structural and fluid simulation. When simulations require a second opinion, ANSYS is utilized.","title":"Hardware"},{"location":"welcome/","text":"Getting Started Welcome to our team! If you are reading this, it might mean that you are either a potential member or new member of our team. Outlined in this page are the basic steps for joining. Please note, general meetings are held over Zoom on Wednesday's at 8:00PM CST and in UNL Nebraska Hall W347 . Join Zoom Meeting https://unl.zoom.us/j/98614962923 Meeting ID: 986 1496 2923 For any additional questions, please check out the Contact Us page! Team Communication Most team communication is done through Slack on the UNL Aerospace #uav-general channel. Team meetings will be held either in person or remote or both during the year. To make sure you are the most up to date with current communication, please download Slack and Zoom as outlined below. To track progress, a progress management and Kanban board tool, Quire is used. Slack To download slack, please visit the Slack Download Link . After downloading slack, request to join the Aerospace channel at unlaerospace.slack.com or by sending an email to one of the club leads on the Contact Us page. After joining the UNL Aerospace slack, request to join the #uav-general channel, and any other UAV specific channel you might be interested in, whether it be hardware, software, etc. Quire To join the Quire board, use the link https://quire.io/c/unl_uav or reach out to a team lead. Quire supports Mac, Windows, and Android and iPhone apps as well. Quire is the software we use for project tracking. Weekly objective information will be posted to Quire on a Kanban style board. Learn more about what Quire is Here . Zoom General meetings and subteam specific meetings will be held during the week to update on progress and to work. These meetings will be held in person or over Zoom. To download zoom go to the link here Zoom Download . Zoom meeting invites will be sent out in the slack channel to attend remotely. Mission Rules Now that you have downloaded and are part of our primary means of communication, the next step in the process is being knowledgeable of the mission rules and organizer website. Please read the What is AUVSI IARC subheading to know what our organizer is and does, in addition to the Mission 9 Objective to understand the rules under the Home page. After reading these sections, make sure to visit the Mission 9 Rules Link to download and view the mission rules. Understanding the mission objectives, rules, and story is very important in understanding the scope of what type of work you will be doing, so make sure to read this document! IARC Mission 9 has challenged us to build and program a fully autonomous aerial system that is capable of performing tasks in mid-air. Below is a gist of Mission 9 objectives: Fly fully autonomous Use ONBOARD Computing (no data links except for kill switch and safety pilot override) Avoid other aerial robots Avoid physical obstacles Conduct the mission successfully (replace a communication module and return home) under 9 minutes Administrative Unless specified, all forms should be send via email to one of the team leads from the Contact Us page! Dues Dues are $20 and can be directly paid to the club treasurer, or any one of the team leads. Contact Khawm Mung on the People page. Cash is preferred. Outreach Requirements This year, due to policies put into effect because of Covid-19, completing the two hours outreach requirements is temporarily not required. Members can and will have the opportunity to participate in outreach events, if desired. This usually entails advertising the Aerospace club at a club fair or volunteering with kids as an aerospace ambassador. Lab Safety Trainings Safety training can be completed independently, however, there will be an opportunity to knock out safety training in one sitting. Upon completing safety training, lab access agreement form, and dues, members are granted lab access. To complete club safety training, visit this website: https://ehs.unl.edu/web-based-training Once there, you will need to click on the four hyperlinks for Core \u2013 Injury and Illness Prevention Plan (IIPP) Core \u2013 Emergency Preparedness Training General Electrical Safety Awareness Personal Protective Equipment (PPE). You will be provided material to read for each one and then a quiz to take after you have read it. Once you pass the quiz, you should receive an email from the site saying that you have done so. When you receive this email, please forward it to unl.aerospace.safety.training@gmail.com Forms to Submit Travelers Form Lab Access Other Information Team Structure The team is loosely divided into hardware and software. The hardware group is responsible for designing and constructing the drones needed for design decisions. They are responsible for developing the drones\u2019 autonomy, supporting the hardware requirements for the software, and maintaining the telemetry feed. The software group is responsible for developing the on-board computer vision systems that receive commands and transmit parsed images to the operator. Funding The UAV team gets its primary funding from two sources: NASA Nebraska and eSAB. NASA Nebraska is the largest source of funding, usually granting us between $6,500 - $8,000 each year. This year the grant award amount is capped at $7000. eSAB funding is reimburse-only, meaning members would need to make the initial purchase and then get reimbursed for the amount later. We are usually granted between $3,750 - $5,000 from eSAB. Travelling For Mission 9, IARC is hosting the competition at Front Royal, Virginia. The competition is usually a three days event and occurs during the first few weeks of August. To travel, members must have paid their dues, completed safety training, and completed their outreach requirements. Useful Links UNL Aerospace Website UNL UAV website IARC Mission 9 Rules Slack Desktop App Download UNL Aerospace GitHub UAV Quire AUVSI IARC Foundation Website","title":"Getting Started"},{"location":"welcome/#getting-started","text":"Welcome to our team! If you are reading this, it might mean that you are either a potential member or new member of our team. Outlined in this page are the basic steps for joining. Please note, general meetings are held over Zoom on Wednesday's at 8:00PM CST and in UNL Nebraska Hall W347 . Join Zoom Meeting https://unl.zoom.us/j/98614962923 Meeting ID: 986 1496 2923 For any additional questions, please check out the Contact Us page!","title":"Getting Started"},{"location":"welcome/#team-communication","text":"Most team communication is done through Slack on the UNL Aerospace #uav-general channel. Team meetings will be held either in person or remote or both during the year. To make sure you are the most up to date with current communication, please download Slack and Zoom as outlined below. To track progress, a progress management and Kanban board tool, Quire is used.","title":"Team Communication"},{"location":"welcome/#slack","text":"To download slack, please visit the Slack Download Link . After downloading slack, request to join the Aerospace channel at unlaerospace.slack.com or by sending an email to one of the club leads on the Contact Us page. After joining the UNL Aerospace slack, request to join the #uav-general channel, and any other UAV specific channel you might be interested in, whether it be hardware, software, etc.","title":"Slack"},{"location":"welcome/#quire","text":"To join the Quire board, use the link https://quire.io/c/unl_uav or reach out to a team lead. Quire supports Mac, Windows, and Android and iPhone apps as well. Quire is the software we use for project tracking. Weekly objective information will be posted to Quire on a Kanban style board. Learn more about what Quire is Here .","title":"Quire"},{"location":"welcome/#zoom","text":"General meetings and subteam specific meetings will be held during the week to update on progress and to work. These meetings will be held in person or over Zoom. To download zoom go to the link here Zoom Download . Zoom meeting invites will be sent out in the slack channel to attend remotely.","title":"Zoom"},{"location":"welcome/#mission-rules","text":"Now that you have downloaded and are part of our primary means of communication, the next step in the process is being knowledgeable of the mission rules and organizer website. Please read the What is AUVSI IARC subheading to know what our organizer is and does, in addition to the Mission 9 Objective to understand the rules under the Home page. After reading these sections, make sure to visit the Mission 9 Rules Link to download and view the mission rules. Understanding the mission objectives, rules, and story is very important in understanding the scope of what type of work you will be doing, so make sure to read this document! IARC Mission 9 has challenged us to build and program a fully autonomous aerial system that is capable of performing tasks in mid-air. Below is a gist of Mission 9 objectives: Fly fully autonomous Use ONBOARD Computing (no data links except for kill switch and safety pilot override) Avoid other aerial robots Avoid physical obstacles Conduct the mission successfully (replace a communication module and return home) under 9 minutes","title":"Mission Rules"},{"location":"welcome/#administrative","text":"Unless specified, all forms should be send via email to one of the team leads from the Contact Us page!","title":"Administrative"},{"location":"welcome/#dues","text":"Dues are $20 and can be directly paid to the club treasurer, or any one of the team leads. Contact Khawm Mung on the People page. Cash is preferred.","title":"Dues"},{"location":"welcome/#outreach-requirements","text":"This year, due to policies put into effect because of Covid-19, completing the two hours outreach requirements is temporarily not required. Members can and will have the opportunity to participate in outreach events, if desired. This usually entails advertising the Aerospace club at a club fair or volunteering with kids as an aerospace ambassador.","title":"Outreach Requirements"},{"location":"welcome/#lab-safety-trainings","text":"Safety training can be completed independently, however, there will be an opportunity to knock out safety training in one sitting. Upon completing safety training, lab access agreement form, and dues, members are granted lab access. To complete club safety training, visit this website: https://ehs.unl.edu/web-based-training Once there, you will need to click on the four hyperlinks for Core \u2013 Injury and Illness Prevention Plan (IIPP) Core \u2013 Emergency Preparedness Training General Electrical Safety Awareness Personal Protective Equipment (PPE). You will be provided material to read for each one and then a quiz to take after you have read it. Once you pass the quiz, you should receive an email from the site saying that you have done so. When you receive this email, please forward it to unl.aerospace.safety.training@gmail.com","title":"Lab Safety Trainings"},{"location":"welcome/#forms-to-submit","text":"Travelers Form Lab Access","title":"Forms to Submit"},{"location":"welcome/#other-information","text":"","title":"Other Information"},{"location":"welcome/#team-structure","text":"The team is loosely divided into hardware and software. The hardware group is responsible for designing and constructing the drones needed for design decisions. They are responsible for developing the drones\u2019 autonomy, supporting the hardware requirements for the software, and maintaining the telemetry feed. The software group is responsible for developing the on-board computer vision systems that receive commands and transmit parsed images to the operator.","title":"Team Structure"},{"location":"welcome/#funding","text":"The UAV team gets its primary funding from two sources: NASA Nebraska and eSAB. NASA Nebraska is the largest source of funding, usually granting us between $6,500 - $8,000 each year. This year the grant award amount is capped at $7000. eSAB funding is reimburse-only, meaning members would need to make the initial purchase and then get reimbursed for the amount later. We are usually granted between $3,750 - $5,000 from eSAB.","title":"Funding"},{"location":"welcome/#travelling","text":"For Mission 9, IARC is hosting the competition at Front Royal, Virginia. The competition is usually a three days event and occurs during the first few weeks of August. To travel, members must have paid their dues, completed safety training, and completed their outreach requirements.","title":"Travelling"},{"location":"welcome/#useful-links","text":"UNL Aerospace Website UNL UAV website IARC Mission 9 Rules Slack Desktop App Download UNL Aerospace GitHub UAV Quire AUVSI IARC Foundation Website","title":"Useful Links"},{"location":"drafts/","text":"Drafts Hey, you found me. You read the docs :*","title":"Drafts"},{"location":"drafts/#drafts","text":"Hey, you found me. You read the docs :*","title":"Drafts"},{"location":"drafts/software/","text":"Software Welcome to the software section! Table of Contents Meet the Team FAQ Resources C++ Premake MavLink RoS","title":"Software"},{"location":"drafts/software/#software","text":"Welcome to the software section!","title":"Software"},{"location":"drafts/software/#table-of-contents","text":"Meet the Team FAQ Resources C++ Premake MavLink RoS","title":"Table of Contents"},{"location":"drafts/software/cpp/","text":"C++ The whole project will be based around C++. C++ is a fast language, but it's also very complicated. By using this tutorial you will have the basics of C++ down. This whole tutorial is based heavily upon some java experiances. Contact a software team lead if you have trouble understanding a concept. Learn C++ via videos This whole documentation is just a dumbed down version of what c++ entails. There is more resources and more concepts behind everything. I recommend that if you get stuck on something checkout the C++ videos by TheCherno . As the guy make pretty good in-depth explination on each concept. You can checkout their C++ playlist here . Compiler C++ is a compiled language meaning that there is a program that sits in front of your source code. That program take in file and output an executable. On GNU/Linux we it would be most likely be g++. There are other programs like catkin, make, premake. Whose job is to generate project files and structure your projects. With ROS we will be using catkin, which is a dirivative of make. Pre-Proccessing In C++ they have an feature called pre-procesing. That will execute before compile-time. These woule be our common #include or #pragma once . #include basically copy and paste a file into the current file. We will be using this a lot because in source files we need to refrence our header file for our code and other header files. We can say this is our import statment in java. #pragma once is called an header guard. This basically prevent copying your declairation twice. It will solve some of the errors with C++. In the old days we would have to do somthing like #ifndef _CLASS #define _CLASS /** YOUR H File HERE */ #endif Headers Headers are one of the file types you find in C++. They contain the declaration of your code. In short it says there exists a function/class/method. That has these parmeters. These files are typically ends with a .h or .hpp. Source Files Source files are files that contain the body of the function. These are typically in .c or .cpp files. Data types We have all the common data types from java bool - Boolean char - Character int - Integer float - Floating point double - Double Percision Floating Point void - valueless We have modifiers that change the data type. signed - positive and negative values unsigned - only positive values short - reduced size long - increased size; Here is a table with most of the primitive data types Data Type Width Range char 1 byte -127-127 or 0-255 unsigned char 1 byte 0-255 signed char 1 byte -127-127 int 4 bytes -2147483648 - 2147483647 unsigned int 4 bytes 0 to 4294967295 singed int 4 bytes -2147483648 - 2147483647 short int 2 bytes -32768 - 32767 unsigned short int 2 bytes 0 to 65535 signed short int 2 bytes -32768 - 32767 long int 8 bytes -2147483648 - 2147483647 signed long int 8 bytes same as long int unsigned long int 8 bytes 0 - 4294967295 long long int 8 bytes -(2^63) - (2^63)-1 unsigned long long int 8 bytes 0 - 18446744073709551615 float 4 bytes double 8 bytes long double 12 bytes We can use the sizeof() operator to get the size in bytes. For example sizeof(int) would output 4. While sizeof(varible) will output the size of the varible. Pointers One of the most important data type in C++ is pointers. Pointers can be very complicated, but all you need to know is that a pointer is just a varible that holds a memory address . That's it. To get a pointer type we can use the memory address operator & . Then to decode that memory address we can use the derefrence operator * . See Example (Pointers-1) We can also declare arrays as a pointer to the first object. See Example (Pointers-2). One of the pitfalls of having a pointer as an array type is that you don't know the size of the array. You may run in to a segmentation fault. That's why we pass though the size of the array. Take a look at the main function in Example (Pointers-2) Pointers-1 #include \"pch.hpp\" int main(){ int i = 3287; int* pI = &i; // Pointer to I. This contain the memory address of I std::cout << *(pI) << std::endl // Dereference the pointer and print out the value at I. } Pointers-2 #include \"pch.hpp\" int main(char* argv, int argc){ int array[] = {3,2,8,7,9}; int* pArray = array; const char* str = \"Hello World\"; // A string is just a const char pointer. Other also known as a character array. } References Like pointers, references are alias to the actual varibles. We use it when we want to modify the original data (to prevent copying). See Example (References-1). A reference must be instaciated. References-1 #include \"pch.hpp\" void modifyString(std::string str){ str + \" bar\"; } void modifyStringRef(std::string& str){ str+\" bar\" } int main(){ std::string var = \"foo\"; modifyString(var); std::cout << var << std::endl; // will just print out \"foo\" modifyStringRef(var); std::cout << var << std::endl; // will print out \"foo bar\" } Scopes In general, the scope is defined as the extent up to which something can be worked with. In programming also the scope of a variable is defined as the extent of the program code within which the variable can we accessed or declared or worked with. Stack e allocation happens on contiguous blocks of memory. We call it stack memory allocation because the allocation happens in function call stack. The size of memory to be allocated is known to compiler and whenever a function is called, its variables get memory allocated on the stack. And whenever the function call is over, the memory for the variables is deallocated. This all happens using some predefined routines in compiler. Programmer does not have to worry about memory allocation and deallocation of stack variables. The stack has very little space (Appox 1MB). Heap The memory is allocated during execution of instructions written by programmers. Note that the name heap has nothing to do with heap data structure. It is called heap because it is a pile of memory space available to programmers to allocated and de-allocate. If a programmer does not handle this memory well, memory leak can happen in the program. Objects C++ is a Object Orientated Language. It's layed out like Java, but it have the ability to be turned functional programming (C/Python). To instanciate a class you can use the following format to start on the stack: Foo f(); // or Foo f; To instaciate a class on the heap you can use the following format. Foo* f = new Foo(); // Processing delete f; // Every time we call new we call delete. Otherwise we get a memory leak. Memory leak is bad. Class A class is an object that has visiblity. The main components of a class is it's member varibles, member functions, constructors, destructor. Constructor Constructors is a function that get executed to set up the object once instanciated. Member Varibles These are varibles that is owned by the class. Member functions These are functions that is owned by the class. They define the behaviour of the class. Destructor This is a function that will get called when a class need to be destroyed. Here is an example on laying out your class in a header file. Foo.hpp: #pragma once #include <string> class Foo{ private: int _i1; std::string _bar; static int _COUNT; public: Foo(); // Constructor void foo(); void bar(); inline int getI1() const { return _i1;}; inline std::string& getBar() {return _bar;}; ~Foo(); // Destructor private: }; Foo.cpp #include \"Foo.hpp\" static int Foo::_COUNT = 0; Foo::Foo(){ // Implement Constructor } void Foo::foo(){ // Implement Foo } void Foo::bar(){ // Implement bar } Foo::~Foo(){ // Implment Destructor } Structs Another type of object is called a struct. A struct is just a class with no visibility at all(all public) struct config{ std::string name; float fov; //... } Inheratence TODO Other","title":"C++"},{"location":"drafts/software/cpp/#c","text":"The whole project will be based around C++. C++ is a fast language, but it's also very complicated. By using this tutorial you will have the basics of C++ down. This whole tutorial is based heavily upon some java experiances. Contact a software team lead if you have trouble understanding a concept.","title":"C++"},{"location":"drafts/software/cpp/#learn-c-via-videos","text":"This whole documentation is just a dumbed down version of what c++ entails. There is more resources and more concepts behind everything. I recommend that if you get stuck on something checkout the C++ videos by TheCherno . As the guy make pretty good in-depth explination on each concept. You can checkout their C++ playlist here .","title":"Learn C++ via videos"},{"location":"drafts/software/cpp/#compiler","text":"C++ is a compiled language meaning that there is a program that sits in front of your source code. That program take in file and output an executable. On GNU/Linux we it would be most likely be g++. There are other programs like catkin, make, premake. Whose job is to generate project files and structure your projects. With ROS we will be using catkin, which is a dirivative of make.","title":"Compiler"},{"location":"drafts/software/cpp/#pre-proccessing","text":"In C++ they have an feature called pre-procesing. That will execute before compile-time. These woule be our common #include or #pragma once . #include basically copy and paste a file into the current file. We will be using this a lot because in source files we need to refrence our header file for our code and other header files. We can say this is our import statment in java. #pragma once is called an header guard. This basically prevent copying your declairation twice. It will solve some of the errors with C++. In the old days we would have to do somthing like #ifndef _CLASS #define _CLASS /** YOUR H File HERE */ #endif","title":"Pre-Proccessing"},{"location":"drafts/software/cpp/#headers","text":"Headers are one of the file types you find in C++. They contain the declaration of your code. In short it says there exists a function/class/method. That has these parmeters. These files are typically ends with a .h or .hpp.","title":"Headers"},{"location":"drafts/software/cpp/#source-files","text":"Source files are files that contain the body of the function. These are typically in .c or .cpp files.","title":"Source Files"},{"location":"drafts/software/cpp/#data-types","text":"We have all the common data types from java bool - Boolean char - Character int - Integer float - Floating point double - Double Percision Floating Point void - valueless We have modifiers that change the data type. signed - positive and negative values unsigned - only positive values short - reduced size long - increased size; Here is a table with most of the primitive data types Data Type Width Range char 1 byte -127-127 or 0-255 unsigned char 1 byte 0-255 signed char 1 byte -127-127 int 4 bytes -2147483648 - 2147483647 unsigned int 4 bytes 0 to 4294967295 singed int 4 bytes -2147483648 - 2147483647 short int 2 bytes -32768 - 32767 unsigned short int 2 bytes 0 to 65535 signed short int 2 bytes -32768 - 32767 long int 8 bytes -2147483648 - 2147483647 signed long int 8 bytes same as long int unsigned long int 8 bytes 0 - 4294967295 long long int 8 bytes -(2^63) - (2^63)-1 unsigned long long int 8 bytes 0 - 18446744073709551615 float 4 bytes double 8 bytes long double 12 bytes We can use the sizeof() operator to get the size in bytes. For example sizeof(int) would output 4. While sizeof(varible) will output the size of the varible.","title":"Data types"},{"location":"drafts/software/cpp/#pointers","text":"One of the most important data type in C++ is pointers. Pointers can be very complicated, but all you need to know is that a pointer is just a varible that holds a memory address . That's it. To get a pointer type we can use the memory address operator & . Then to decode that memory address we can use the derefrence operator * . See Example (Pointers-1) We can also declare arrays as a pointer to the first object. See Example (Pointers-2). One of the pitfalls of having a pointer as an array type is that you don't know the size of the array. You may run in to a segmentation fault. That's why we pass though the size of the array. Take a look at the main function in Example (Pointers-2) Pointers-1 #include \"pch.hpp\" int main(){ int i = 3287; int* pI = &i; // Pointer to I. This contain the memory address of I std::cout << *(pI) << std::endl // Dereference the pointer and print out the value at I. } Pointers-2 #include \"pch.hpp\" int main(char* argv, int argc){ int array[] = {3,2,8,7,9}; int* pArray = array; const char* str = \"Hello World\"; // A string is just a const char pointer. Other also known as a character array. }","title":"Pointers"},{"location":"drafts/software/cpp/#references","text":"Like pointers, references are alias to the actual varibles. We use it when we want to modify the original data (to prevent copying). See Example (References-1). A reference must be instaciated. References-1 #include \"pch.hpp\" void modifyString(std::string str){ str + \" bar\"; } void modifyStringRef(std::string& str){ str+\" bar\" } int main(){ std::string var = \"foo\"; modifyString(var); std::cout << var << std::endl; // will just print out \"foo\" modifyStringRef(var); std::cout << var << std::endl; // will print out \"foo bar\" }","title":"References"},{"location":"drafts/software/cpp/#scopes","text":"In general, the scope is defined as the extent up to which something can be worked with. In programming also the scope of a variable is defined as the extent of the program code within which the variable can we accessed or declared or worked with.","title":"Scopes"},{"location":"drafts/software/cpp/#stack","text":"e allocation happens on contiguous blocks of memory. We call it stack memory allocation because the allocation happens in function call stack. The size of memory to be allocated is known to compiler and whenever a function is called, its variables get memory allocated on the stack. And whenever the function call is over, the memory for the variables is deallocated. This all happens using some predefined routines in compiler. Programmer does not have to worry about memory allocation and deallocation of stack variables. The stack has very little space (Appox 1MB).","title":"Stack"},{"location":"drafts/software/cpp/#heap","text":"The memory is allocated during execution of instructions written by programmers. Note that the name heap has nothing to do with heap data structure. It is called heap because it is a pile of memory space available to programmers to allocated and de-allocate. If a programmer does not handle this memory well, memory leak can happen in the program.","title":"Heap"},{"location":"drafts/software/cpp/#objects","text":"C++ is a Object Orientated Language. It's layed out like Java, but it have the ability to be turned functional programming (C/Python). To instanciate a class you can use the following format to start on the stack: Foo f(); // or Foo f; To instaciate a class on the heap you can use the following format. Foo* f = new Foo(); // Processing delete f; // Every time we call new we call delete. Otherwise we get a memory leak. Memory leak is bad.","title":"Objects"},{"location":"drafts/software/cpp/#class","text":"A class is an object that has visiblity. The main components of a class is it's member varibles, member functions, constructors, destructor.","title":"Class"},{"location":"drafts/software/cpp/#constructor","text":"Constructors is a function that get executed to set up the object once instanciated.","title":"Constructor"},{"location":"drafts/software/cpp/#member-varibles","text":"These are varibles that is owned by the class.","title":"Member Varibles"},{"location":"drafts/software/cpp/#member-functions","text":"These are functions that is owned by the class. They define the behaviour of the class.","title":"Member functions"},{"location":"drafts/software/cpp/#destructor","text":"This is a function that will get called when a class need to be destroyed. Here is an example on laying out your class in a header file. Foo.hpp: #pragma once #include <string> class Foo{ private: int _i1; std::string _bar; static int _COUNT; public: Foo(); // Constructor void foo(); void bar(); inline int getI1() const { return _i1;}; inline std::string& getBar() {return _bar;}; ~Foo(); // Destructor private: }; Foo.cpp #include \"Foo.hpp\" static int Foo::_COUNT = 0; Foo::Foo(){ // Implement Constructor } void Foo::foo(){ // Implement Foo } void Foo::bar(){ // Implement bar } Foo::~Foo(){ // Implment Destructor }","title":"Destructor"},{"location":"drafts/software/cpp/#structs","text":"Another type of object is called a struct. A struct is just a class with no visibility at all(all public) struct config{ std::string name; float fov; //... }","title":"Structs"},{"location":"drafts/software/cpp/#inheratence","text":"TODO","title":"Inheratence"},{"location":"drafts/software/cpp/#other","text":"","title":"Other"},{"location":"drafts/software/faq/","text":"FAQ","title":"FAQ"},{"location":"drafts/software/faq/#faq","text":"","title":"FAQ"},{"location":"drafts/software/mavlink/","text":"Mavlink Description Mavlink is a communication protocol that was created to be able to send/receive messages in a unifrom fasihon. The messages are defined in xml files which is refererred to as the dialect of the protocol. A maximum of 255 devices can be connected via the mavlink protocl, and it only uses 14 bytes of overhead. Different Messages The message above is an attitude message that can be used to communicate to the drone what you want it to act like. The messages function as a packet and every message is composed of the same commponents. A full list of the mavlink packets can be found here . Message Components More information can be found here","title":"Mavlink"},{"location":"drafts/software/mavlink/#mavlink","text":"","title":"Mavlink"},{"location":"drafts/software/mavlink/#description","text":"Mavlink is a communication protocol that was created to be able to send/receive messages in a unifrom fasihon. The messages are defined in xml files which is refererred to as the dialect of the protocol. A maximum of 255 devices can be connected via the mavlink protocl, and it only uses 14 bytes of overhead.","title":"Description"},{"location":"drafts/software/mavlink/#different-messages","text":"The message above is an attitude message that can be used to communicate to the drone what you want it to act like. The messages function as a packet and every message is composed of the same commponents. A full list of the mavlink packets can be found here .","title":"Different Messages"},{"location":"drafts/software/mavlink/#message-components","text":"More information can be found here","title":"Message Components"},{"location":"drafts/software/premake/","text":"Premake","title":"Premake"},{"location":"drafts/software/premake/#premake","text":"","title":"Premake"},{"location":"drafts/software/resources/","text":"Resources","title":"Resources"},{"location":"drafts/software/resources/#resources","text":"","title":"Resources"},{"location":"drafts/software/ros/","text":"RoS","title":"RoS"},{"location":"drafts/software/ros/#ros","text":"","title":"RoS"},{"location":"drafts/software/simulation/","text":"mavROS-Simulation Information Repository for getting the simulation up and running. This is using ros and gazebo simulation software. Prerequisite The enviroment you need for the simulation software needs to be ubuntu, any version later than 18.04 should work. The list of things that need to be installed before you can begin using the simulation is in the list below: ROS mavROS geographicLib gazebo px4 firmware GSTREAMER 1 If you have not used ROS before then I would suggest reading through and doing the tutorials. Once you have a basic understanding you should come back and begin using the simulation. A small preview of how this simulation works is in the diagram below: Directions for Installation First you should install ROS, you can use any version that you want to. This tutorial was written using ubuntu 20.04 and the newest realease of ROS, Noetic. You can find the instructions to install ROS The next things that you need to install will be mavROS . You will need to install mavROS by using the commands below sudo apt-get install ros-version-mavros ros-version-mavros-extras Replace version above with your version of mavros. for example if you are using noetic, use ros-version-mavros Next you are going to need to get the geagraphic lib, you need this for mavros so that you can send long/lat. The command is below: wget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh sudo chmod +x install_geographiclib_datasets.sh sudo ./install_geographiclib_datasets.sh You do not need to explicitly install gazebo unless you did not install the full desktop version of ROS The px4 firmware is what is need to simulate the flight controller, and ROS is what is going to be controlling the simulated flight controller. To install the px4 firmware you can fork the repository from our github page or just pull it if you aren't planning on messing with the firmware code, the command is below: git clone git@github.com:UNL-UAV/Firmware.git cd Firmware next you are going to have to install some package dependencies so that you can make the simulation px4 flight controller, please run the commands below to be able to build. sudo apt-get install libprotobuf-dev libprotoc-dev protobuf-compiler libeigen3-dev libxml2-utils python-rospkg python-jinja2 sudo apt-get install libgstreamer-plugins-base1.0-dev gstreamer1.0-plugins-bad gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-ugly -y Now you can run the simulation by using the command below (be sure you're in the Firmware directory that was pulled from Github). It is going to take a really long time to build the first time but afterwards it shouldn't take super long. Also there might be errors that come up because of some other dependencies that weren't included in the installation process, they should all be explicit instructions to install a certain dependency, you should be able to follow the error and resolve it. make px4_sitl gazebo Directions for Running To understand how to run, it is best to understand the logic of how the simulation is running. Look at the diagram above one more time to try and understand it. Theres three different things that need to be running for the simulation to work. First you need to run the gazebo simulation and also connect it to the sitl px4 controller. Then you need to run ROS to create the connection and control the pixhawk. Then you need to run ROS nodes to populate certain topics to control the simulation. Run the gazebo simulation and run the sitl pixhawk. This needs to be done from the Firmware repository directory as all the make files for this command are there. make px4_sitl gazebo To run the ROS simulation you need to launch ROS and connect it to your computer, or you can connect it two whichever computer is running the px4 simulation. roslaunch mavros px4.launch fcu_url:=\"udp://:14540@127.0.0.1:14557\" Then you can run nodes to control your drone. At thsis point all the information between ROS and the sitl pixhawk should be working. This means that you can not run nodes to populate topics to control the drone. If you have not already built nodes, there is an example takeoff already supplied in the repository. To run the takeoff node you have to move to this repository, ..../mavROS-Simulation then run the commands below. If for some reason the code does not compile after catkin_make, check the CMakeLists.txt to make sure the right version of everything is included. catkin_make source devel/setup.bash rosrun examples takeoff_example","title":"mavROS-Simulation"},{"location":"drafts/software/simulation/#mavros-simulation","text":"","title":"mavROS-Simulation"},{"location":"drafts/software/simulation/#information","text":"Repository for getting the simulation up and running. This is using ros and gazebo simulation software.","title":"Information"},{"location":"drafts/software/simulation/#prerequisite","text":"The enviroment you need for the simulation software needs to be ubuntu, any version later than 18.04 should work. The list of things that need to be installed before you can begin using the simulation is in the list below: ROS mavROS geographicLib gazebo px4 firmware GSTREAMER 1 If you have not used ROS before then I would suggest reading through and doing the tutorials. Once you have a basic understanding you should come back and begin using the simulation. A small preview of how this simulation works is in the diagram below:","title":"Prerequisite"},{"location":"drafts/software/simulation/#directions-for-installation","text":"First you should install ROS, you can use any version that you want to. This tutorial was written using ubuntu 20.04 and the newest realease of ROS, Noetic. You can find the instructions to install ROS The next things that you need to install will be mavROS . You will need to install mavROS by using the commands below sudo apt-get install ros-version-mavros ros-version-mavros-extras Replace version above with your version of mavros. for example if you are using noetic, use ros-version-mavros Next you are going to need to get the geagraphic lib, you need this for mavros so that you can send long/lat. The command is below: wget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh sudo chmod +x install_geographiclib_datasets.sh sudo ./install_geographiclib_datasets.sh You do not need to explicitly install gazebo unless you did not install the full desktop version of ROS The px4 firmware is what is need to simulate the flight controller, and ROS is what is going to be controlling the simulated flight controller. To install the px4 firmware you can fork the repository from our github page or just pull it if you aren't planning on messing with the firmware code, the command is below: git clone git@github.com:UNL-UAV/Firmware.git cd Firmware next you are going to have to install some package dependencies so that you can make the simulation px4 flight controller, please run the commands below to be able to build. sudo apt-get install libprotobuf-dev libprotoc-dev protobuf-compiler libeigen3-dev libxml2-utils python-rospkg python-jinja2 sudo apt-get install libgstreamer-plugins-base1.0-dev gstreamer1.0-plugins-bad gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-ugly -y Now you can run the simulation by using the command below (be sure you're in the Firmware directory that was pulled from Github). It is going to take a really long time to build the first time but afterwards it shouldn't take super long. Also there might be errors that come up because of some other dependencies that weren't included in the installation process, they should all be explicit instructions to install a certain dependency, you should be able to follow the error and resolve it. make px4_sitl gazebo","title":"Directions for Installation"},{"location":"drafts/software/simulation/#directions-for-running","text":"To understand how to run, it is best to understand the logic of how the simulation is running. Look at the diagram above one more time to try and understand it. Theres three different things that need to be running for the simulation to work. First you need to run the gazebo simulation and also connect it to the sitl px4 controller. Then you need to run ROS to create the connection and control the pixhawk. Then you need to run ROS nodes to populate certain topics to control the simulation. Run the gazebo simulation and run the sitl pixhawk. This needs to be done from the Firmware repository directory as all the make files for this command are there. make px4_sitl gazebo To run the ROS simulation you need to launch ROS and connect it to your computer, or you can connect it two whichever computer is running the px4 simulation. roslaunch mavros px4.launch fcu_url:=\"udp://:14540@127.0.0.1:14557\" Then you can run nodes to control your drone. At thsis point all the information between ROS and the sitl pixhawk should be working. This means that you can not run nodes to populate topics to control the drone. If you have not already built nodes, there is an example takeoff already supplied in the repository. To run the takeoff node you have to move to this repository, ..../mavROS-Simulation then run the commands below. If for some reason the code does not compile after catkin_make, check the CMakeLists.txt to make sure the right version of everything is included. catkin_make source devel/setup.bash rosrun examples takeoff_example","title":"Directions for Running"},{"location":"drafts/software/team/","text":"Meet the team Timothy Gibbons","title":"Meet the team"},{"location":"drafts/software/team/#meet-the-team","text":"","title":"Meet the team"},{"location":"drafts/software/team/#timothy-gibbons","text":"","title":"Timothy Gibbons"}]}